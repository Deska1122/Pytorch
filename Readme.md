# Классификация набора данных Iris с использованием нейронной сети

Этот проект демонстрирует создание, обучение и оценку нейронной сети для классификации набора данных Iris с использованием PyTorch. Набор данных Iris - это классический набор данных для задач классификации, и в этом примере используется простая нейронная сеть прямого распространения для предсказания класса цветка Iris.

## Содержание
- [Установка](#установка)
- [Набор данных](#набор-данных)
- [Предобработка](#предобработка)
- [Архитектура модели](#архитектура-модели)
- [Обучение](#обучение)
- [Оценка](#оценка)
- [Результаты](#результаты)
- [Лицензия](#лицензия)

## Установка

Для запуска этого кода вам понадобятся Python и несколько установленных пакетов.

## Набор данных

Набор данных Iris - это известный набор данных в машинном обучении. Он состоит из 150 образцов трех видов цветов Iris: Iris setosa, Iris versicolor и Iris virginica. У каждого образца четыре признака: длина чашелистника, ширина чашелистника, длина лепестка и ширина лепестка.

## Предобработка

Шаги предварительной обработки данных включают в себя:

1. **Загрузка набора данных:** Использование `sklearn.datasets.load_iris()` для загрузки набора данных Iris.
2. **Масштабирование признаков:** Стандартизация признаков с использованием `StandardScaler`.
3. **Разделение данных:** Разделение набора данных на обучающую и тестовую выборки в соотношении 80:20 с использованием `train_test_split`.
4. **Преобразование в тензоры:** Преобразование numpy массивов в тензоры PyTorch для использования в нейронной сети.

## Архитектура модели

Нейронная сеть - это простая сеть прямого распространения со следующей архитектурой:

- **Входной слой:** 4 входных признака.
- **Скрытый слой 1:** 64 нейрона с функцией активации ReLU.
- **Скрытый слой 2:** 64 нейрона с функцией активации ReLU.
- **Выходной слой:** 3 нейрона (по одному для каждого класса) без активации (для использования с CrossEntropyLoss).

## Обучение

Процесс обучения включает в себя:

1. **Создание модели:** Создание экземпляра класса `NeuralNetwork`.
2. **Определение функции потерь:** Использование `nn.CrossEntropyLoss()` для классификации.
3. **Выбор оптимизатора:** Использование оптимизатора Adam с коэффициентом скорости обучения 0.001.
4. **Обучение модели:** Итерация по обучающим данным в течение заданного количества эпох (в данном случае 100), выполнение прямого и обратного проходов, обновление параметров модели.

## Оценка

После обучения модель оценивается на тестовом наборе:

1. **Предсказание:** Использование обученной модели для предсказания классов на тестовом наборе.
2. **Метрика оценки:** Вычисление точности с использованием `precision_score` из scikit-learn.

## Результаты

Производительность модели измеряется с помощью точности, которая учитывает баланс классов в наборе данных. Вывод отобразит точность, показывая эффективность модели в классификации набора данных Iris.

## Лицензия

Этот проект является открытым и доступен по [лицензии MIT](LICENSE).

---